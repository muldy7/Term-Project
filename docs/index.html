<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ME-405 Term Project: ME-405 Term Project Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ME-405 Term Project<span id="projectnumber">&#160;0.3.1</span>
   </div>
   <div id="projectbrief">The following documented code implements a thermal imaging Nerf turret that is able to spin around, find, and shoot thermal targets for the ME-405 Term Project.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ME-405 Term Project Main Page </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>This main page serves as a brief summary of the code and its implementation used to create our Nerf turret for the ME-405 Term Project. The code is documentated in more detail in the generated documentation that can be found on this website.</p>
<h1><a class="anchor" id="files_sec"></a>
Files</h1>
<p>To create our final robot, we used a combination of testing files, classes, and main files. The files are explained in more detail below. The final robot used five classes and one main file that ran the code from a laptop. The classes allow use to use an encoder, motor driver, pd controller, servo driver, and a camera. All these functions were used in the final implementation of the robot.</p>
<h2><a class="anchor" id="main"></a>
Main Project Code Files</h2>
<p><a class="el" href="project__main_8py.html" title="-The Holy Turrent of Antioch-">project_main.py</a>: This file implements code to run our robot in a line-by-line code basis. We used this file from a laptop during the final tournament and testing. This code uses all the classes to turn the robot 180 degrees, wait for 5 seconds, capture a thermal image, move to the target, shoot the target, and then stop. This was written in a similar way to our scheduler, which is detailed, along with its states, below. Our scheduler has the ability to move the robot multiple times, which we had some trouble with perfecting before the tournament. The <a class="el" href="project__main_8py.html" title="-The Holy Turrent of Antioch-">project_main.py</a> just moves the robot once before shooting. Since the code is also not split into tasks it makes it easier to print all of the values used to find the target for easier tuning of the targetting algorithim.</p>
<p>scheduler_main.py: This file implementated our robot using tasks and a scheduler. The code worked in a very similar way to project_main, except it splits the camera and the motor controlling into two seperate tasks. The explanation of these states and tasks is detailed in the 'Tasks and States' section below.</p>
<h2><a class="anchor" id="classes"></a>
Project Classes</h2>
<p>The following classes are the ones written to for use in the creation and implementation of our robot.</p>
<p><a class="el" href="pd__controller_8py.html" title="This file implements pd control of our device with some small changes to the previous controller clas...">pd_controller.py</a>: This file creates a class that implements a PD controller that we used to control our robot. The PD control was used in all elements of our motor movement in our main code to spin the robot and find targets. There are also a <a class="el" href="controller_8py.html" title="This file contains code to create a controller class that allows us to create a control loop to run o...">controller.py</a> and <br  />
 <a class="el" href="pid__controller_8py.html" title="This file attempts to implement pid control of our device with some small changes to the previous con...">pid_controller.py</a> file that work in a similar way but were not used on our final robot.</p>
<p><a class="el" href="encoder__reader_8py.html" title="This file contains code which creates an encoder class for completion of ME-405 Week 2.">encoder_reader.py</a>: This file creates an encoder class that allows use to use the encoder on the <br  />
 motor we used. The encoder class allows use to measure the movement of the motor for calculation of our motor's movement that can be used along with the previous pd_controller to control the robot.</p>
<p><a class="el" href="mlx__cam_8py.html" title="This file was adjusted by our group to include a new function, get_hotspot to use the raw data to fin...">mlx_cam.py</a>: This file was given to us, and creates a class that allows use to use a thermal camera that can find targets for our robot to shoot at. Our group added another function, get_hotspot, takes images from the camera and calculates the location of the target in encoder tics. This encoder tic value was then given to our motor controller so the robot could point and shoot at targets in the <a class="el" href="project__main_8py.html" title="-The Holy Turrent of Antioch-">project_main.py</a> code.</p>
<p><a class="el" href="motor__driver_8py.html" title="This file contains code that creates a class to control a motor for ME-405 Lab01.">motor_driver.py</a>: This file creates a motor_driver class to control the motor powering our robot. A motor object created with this class can be given a PWM value and will spin the motor at that <br  />
 PWM. This file was used in conjuction with the encoder and controller to move the robot.</p>
<p><a class="el" href="servo__driver_8py.html" title="This file contains code that creates a class to control a servo from the STM Nucleo-64 using MicroPyt...">servo_driver.py</a>: This file creates a servo class for controlling a servo motor. We created a servo class for controlling the servo that pulled the trigger of our gun. Sending the servo object a desired angle will spin the servo to that angle.</p>
<h2><a class="anchor" id="test"></a>
Test Code</h2>
<p>gui_tuning.py: This file contains code to run program on a laptop or desktop which creates a user interface that can send a signal to the microcontroller to run a step response. The user can set a Kp, Kd, and Setpoint values and send that to a microcontroller where a Controller Object will read and interpret the data from the motor. This code was used to tune our robot for different step responses during its use. Using the code below we found the best Kp and Kd values for the 180 degree turn, which we found to be different than the optimal gain values for smaller turns that would occur while finding a target.</p>
<p><a class="el" href="main_8py.html" title="THIS IS THE FILE ON THE NUCLEO BOARD.">main.py</a>: This file contains code that was stored on our group's Nucleo board to generate the motor step-response. This file was called by the code on our computer and read through the serial port to generate graphs of our step-response.</p>
<h1><a class="anchor" id="states_sec"></a>
States and Tasks</h1>
<p>The Task and State diagram for our the code implemented in our scheduler_main.py file can be seen below. The two tasks were split up for one to control the motor of the robot and the other to control the robot. Code for these states can be seen in the scheduler_main.py code file.</p>
<div class="image">
<img src="state_space.png" alt=""/>
</div>
<p> Figure 01: Task and State Diagram for our Robot</p>
<h2><a class="anchor" id="task1"></a>
Task 1: Robot Controller</h2>
<p>State 0: INIT This state initializes the robot. This means creating all the necessary flags and classes</p>
<p>State 1: Spin 180 This state always occurs after INIT. This states uses the controller to turn the robot 180 degrees to face the target. This is done with the pd_controller, encoder, and motor_driver. Once the controller error is small enough the robot stops and moves to the next state.</p>
<p>State 2: Control This state takes the setpoint values from the get_hotspot function calculated by the Thermal Camera <br  />
 Task and moves the robot to the desired location. This is done by setting a shared inter-task variable img_flg to zero. This tells the Camera tasks it is ready for a new image. Once the hotspot has been calculated, the value is given to the controller and robot moves to that location. This means that in the five seconds after the turret spins around, it waits for an image, moves to the target location, asks for a new image, waits for the image, and then moves to the new location until five seconds has passed. After it has found the final target location and fives seconds has passed it stops moving and transitions to the next state. With the scheduler, the robot can move multiple times, depending on how much the target has moved, before FREEZE is called.</p>
<p>State 3: Shoot This state simply uses the servo to pull the trigger and shoot the target. This is done by setting the servo to a position that will pull the trigger and then returning the servo to its default position. After the trigger has been pulled the code transitions to the next state.</p>
<p>State 4: Return This code uses the same control loop as the 180 spin to spin the robot back to zero. This is done by just sending the controller a negative value of the value used to spin the robot 180 at the beginning of a duel.</p>
<p>State 5: Stop the Robot This state stops the robots movement and then prints some values for us to verify the final target location. After this state the code is then exited.</p>
<h2><a class="anchor" id="task2"></a>
Task 2: Camera</h2>
<p>State 0: INIT This state initializes the camera with code from mlx_cam. This uses the I2C functionality and ports to control the thermal camera.</p>
<p>State 1: Take a Picture This photo waits for the inter-task variable image_flag to equal zero. Once the flag is lowered the state takes a picture, uses the get_hotspot command to find the location of the target in encoder tics, and then puts that value in the share. The image_flag is then raised to tell the other task there has been a new setpoint value calculated. The state then waits for the image_flag to be <br  />
 lowered again before taking a new image. This is done before the other task exits. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
